#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <cerrno>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <poll.h>
#include <fcntl.h>
#include <thread>

#include <vector>

using namespace std;

static void msg(const char *msg) {
    fprintf(stderr, "%s\n",msg);
}

static void msg_errno(const char *msg){
	fprintf(stderr,"[errno: %d] %s\n",errno,msg);
}

static void die(const char *msg) {
    int err = errno;
    cerr << "[" << err << "] " << msg << endl;
    exit(1);
}

// Set a file descriptor to non-blocking mode

static void fd_set_nb(int fd){
	errno = 0;
	// current file status flags
	int flags=fcntl(fd,F_GETFL,0);
	if(errno){
		die("fcntl error");
		return ;
	}
	// add the O_NONBLOCK flag for non-blocking mode
	flags |= O_NONBLOCK; // using bitwise OR to preserve existing flags and add new ones
	
	errno=0;
	// update the flags back to file descriptor
	(void)fcntl(fd,F_SETFL,flags);
	if(errno){
		die("fcntl error");
	}
}

const size_t k_max_msg = 32 << 20; // larger than kernerl buffer (usually 4 to 8 mb's)- 33,554,432 bytes

struct RingBuffer{
	uint8_t *data = nullptr;
	size_t capacity =0;
	size_t head =0;
	size_t tail =0;
	size_t size =0 ;

	size_t current_size() const { return size; }

	~RingBuffer() {
		if(data) free(data);
	}
};

// initialize buff with size*2 capacity

static void rb_init(RingBuffer &rb , size_t initial_cap){
	initial_cap=1 << (sizeof(size_t)*8 - __builtin_clzll(initial_cap));
	rb.data = (uint8_t*)malloc(initial_cap);
	rb.capacity=initial_cap;
}

//check available space
static bool rb_can_write(const RingBuffer &rb){
	return rb.size < rb.capacity;
}

//wrtie data to buffer(return bytes written)
static size_t rb_write(RingBuffer &rb, const uint8_t *src, size_t len){
	size_t remaining = rb.capacity - rb.size;
	len = min(len,remaining);
	
	if(len==0) return 0;

	// write to the end of the buffer

	size_t first_chunk = min(len, rb.capacity - rb.tail);
	memcpy(rb.data+rb.tail,src,first_chunk);

	/*A ring buffer is a circular data structure. When you reach the end of the buffer, you wrap around to the beginning and continue writing.
So if your buffer has a capacity of 10, and you're at index 8 and want to write 5 bytes, only 2 bytes fit before the end. The remaining 3 bytes must be written starting at index 0.
*/
	if(first_chunk<len){
		memcpy(rb.data,src+first_chunk,len-first_chunk);
	}

	rb.tail = (rb.tail+len)% rb.capacity; 
	/* Without %, your index would go out of bounds, causing memory errors or corrupt data.
The % rb.capacity keeps the index within the valid range [0, capacity - 1].
*/
	rb.size+=len;
	return len;
}


//read data from buffer, return bytes read

static size_t rb_read(RingBuffer &rb, uint8_t *dst, size_t len){
	len =min(len,rb.size);
	if(len==0) return 0;

	// read from head

	size_t first_chunk = min(len,rb.capacity - rb.head);
	memcpy(dst,rb.data+rb.head,first_chunk);
	
	if(first_chunk<len){
		memcpy(dst+first_chunk,rb.data,len-first_chunk);
	}
	rb.head = (rb.head+len) % rb.capacity ;
	rb.size-=len;
	return len;
}

/*  Represents per-connection state in an event-driven server.
    This structure allows the application to manage multiple connections asynchronously,
    storing each connection's read/write intentions, closure status, and buffered I/O data.
*/
struct Conn{
	int fd = -1;
	// applications intention , for the event loop
	bool want_read=false;
	bool want_write=false;
	bool want_close=false;
	// now i'm using vectors for buffer manipulation which easier and cleaner ...
	// buffered input and output_iterator
	RingBuffer incoming ; // data to be parsed by the application
	RingBuffer outgoing ; // responses generated by the application 

	Conn(){
		rb_init(incoming,8192);
		rb_init(outgoing,8192);
	}
};

// Call back function

    static Conn *handle_accept(int fd){
	struct sockaddr_in client_addr={};
	socklen_t addrlen = sizeof(client_addr);
	int connfd=accept(fd , (struct sockaddr*)&client_addr, &addrlen);
	if(connfd<0){
		cerr<<"Accept() error"<<endl;
		return NULL ;
	}
	uint32_t ip = client_addr.sin_addr.s_addr;
	// LSB
	fprintf(stderr," New client from %u.%u.%u.%u.%u\n",
	ip & 255 ,(ip>>8)&255,(ip>>16)&255,ip>>24,
	ntohs(client_addr.sin_port));
	
	//set the connection fd to nonblocking mode 
	fd_set_nb(fd);
	
	//struct conn
	Conn *conn = new Conn();
	conn->fd =connfd;
	conn->want_read=true;
	return conn;
}

// Process 1 request if there is enough data
// THis protocol assumes the first 4 bytes of incoming data hold the length of the message body.

static bool try_one_request(Conn *conn){
	// parse the protocol header 
	if(conn->incoming.size<4){
		return false; // want read 
	}
	
	uint32_t len =0;
	if(conn->incoming.head+4<=conn->incoming.capacity){
		memcpy(&len,conn->incoming.data+conn->incoming.head,4);
	}else{
		// handle wrap around peek
		uint8_t len_buf[4];
        size_t first = conn->incoming.capacity - conn->incoming.head;
        memcpy(len_buf, conn->incoming.data + conn->incoming.head, first);
        memcpy(len_buf + first, conn->incoming.data, 4 - first);
        memcpy(&len, len_buf, 4);
	}
	if(len>k_max_msg){
		msg("too long");
		conn->want_close=true;
		return false ; // want close 
	}
	
	// message body 
	if(4+len>conn->incoming.size){
		return false ; // want read 
	}
	uint8_t dummy[4+len];
	rb_read(conn->incoming,dummy,4+len);
	const uint8_t *request = dummy+4;
	
	// got one request , do some application logic and printing it upto only first 100 char to avoid terminal overloading
	printf("client says: len : %d data : %.*s\n",len,len<100?len:100,request);
	
	// generate the response(echo)
	rb_write(conn->outgoing, (const uint8_t *)&len,4);
	rb_write(conn->outgoing, request ,len);
	
	// application logic done :) remove the request message 
	
	/* we can't just empty the buffer because , multiple requests are coming in the buffer , by the time of responding we may only respond to only one at a time. 
	so after this process emptying the buffer is not suitable cause it may discard the upcoming message requests*/
	return true ;
}

// application callback when the socket is writable

static void handle_write(Conn *conn){
	uint8_t buf[4096];
	size_t to_read = min(sizeof(buf),conn->outgoing.size);

	if(to_read==0){
		conn->want_write=false;
		conn->want_read = true;
		return;
	}
	size_t read = rb_read(conn->outgoing,buf,to_read);
	ssize_t written = write(conn->fd,buf,read);

	if(written<0 && errno== EAGAIN){
	return ; // not ready
	}
	if(written<0){
		msg_errno("write() error)");
		conn->want_close=true; // error handling
		return;
	}
	
	
	// update the readiness intention
	if(conn->outgoing.size==0){
		// all data written 
		conn->want_read=true;
		conn->want_write=false;
	} 
}

// application callback when the socket is readable

static void handle_read(Conn *conn){
	// read some data 
	uint8_t buf[4096];
	ssize_t rv= read(conn->fd,buf,sizeof(buf));
	if(rv>0){
		size_t written=rb_write(conn->incoming,buf,rv);
		if(written<(size_t)rv){
			conn->want_close = true ;
			return;
		}
		while(try_one_request(conn)){}
    	}
	// handle EOF
	if(rv==0){
		if(conn->incoming.size==0){
			msg("client closed");
		}
		else{
			msg("unexpected EOF");
		}
		conn->want_close=true ;
		return ;
	}
	if(rv<0 && errno==EAGAIN){return;}
	if(rv<0){
		msg_errno("read() error");
		conn->want_close = true ;
		return;
	}

    // update readiness intention 
	if(conn->outgoing.size>0){
		// buffer is not empty so stop reading , it was ready to write !!!
		conn->want_read =false;
		conn->want_write=true;
		/* The socket is now ready to write in a request-response protocol,
		try to write it without waiting for the next iteration.*/
	    handle_write(conn);
	} // else want read 
}






int main() {
	// listening socket
    cerr << "Starting server..." << endl;

    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        die("socket()");
    }
    cerr << "Socket created." << endl;

    int val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
	
    //bind
    struct sockaddr_in addr = {};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(1740);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    int rv = bind(fd, (const struct sockaddr *)&addr, sizeof(addr));
    if (rv != 0) {
        die("bind()");
    }
    cerr << "Bind successful." << endl;
    //set the listen fd to nonblocking mode
	fd_set_nb(fd);
	printf("fd was set to non blocking mode\n");
	
	//listen
    rv = listen(fd, SOMAXCONN);
    if (rv != 0) {
        die("listen()");
    }
    cerr << "Listening on port 1740..." << endl;

   // a map of all clients connectios , keyed by fd 
   vector<Conn *> fd2conn;
   // event loop 
   vector<struct pollfd> poll_args;
   while(true){
	   // prepare the arguments of the poll()
	   poll_args.clear(); // clear previous poll arguments 
	   // put listening socket in first position
	   struct pollfd pfd = {fd,POLLIN,0};
	   poll_args.push_back(pfd);
	   
	   // the rest are connection sockets 
	   for(Conn *conn : fd2conn){
		   if(!conn){
			   continue;
		   }
		   // always adds conncetion socket to poll for error
           struct pollfd pfd = {conn->fd,POLLERR,0};
		   if(conn->want_read){
			   pfd.events |= POLLIN;
		   } // Intrested in reading 
		   if(conn->want_write){
			   pfd.events |= POLLOUT ;
		   } // Intrested in writing 
	   
	   poll_args.push_back(pfd);
   }
   // wait for readiness 
   int rv = poll(poll_args.data() , (nfds_t)poll_args.size(),-1);
   if(rv<0 && errno == EINTR){
	   continue;
   }
   if(rv<0){
	   die("poll");
   }
   
   // handle the listening socket
   if(poll_args[0].revents){
	   if(Conn *conn = handle_accept(fd)){
		   if(fd2conn.size() <= (size_t)conn->fd){
			   fd2conn.resize(conn->fd+1);
		   }
		   assert(!fd2conn[conn->fd]); // verify it was not occupied
		   fd2conn[conn->fd]=conn;
	   }
   }
   
   // handle events on existing conncetions 
   for(size_t i=1 ; i<poll_args.size(); i++){
	   // skip the first 
	   uint32_t ready = poll_args[i].revents;
	   if(ready==0){
	   continue;
	   }
   Conn *conn =fd2conn[poll_args[i].fd];
   
   //read data if ready 
   
   if(ready & POLLIN){
	   assert(conn->want_read);
	   handle_read(conn);
   }
   
   // write data if ready 
   
   if(ready & POLLOUT){
	   assert(conn->want_write);
	   handle_write(conn);
   }
   
   // close the socket from socket error or application logic 
   if((ready & POLLERR )||(conn->want_close)){
	   (void)close(conn->fd);
	   fd2conn[conn->fd]=NULL;
	   delete conn ;
      }
    }
  }
    return 0;
}

