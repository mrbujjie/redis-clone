#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <cerrno>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <thread>
#include <fcntl.h>
#include <vector>
#include <poll.h>

using namespace std;

static void msg(const char *msg) {
    fprintf(stderr, "%s\n",msg);
}

static void msg_errno(const char *msg){
	fprintf(stderr,"[errno: %d] %s\n",errno,msg);
}

static void die(const char *msg) {
    int err = errno;
    cerr << "[" << err << "] " << msg << endl;
    exit(1);
}

// Set a file descriptor to non-blocking mode

static void fd_set_nb(int fd){
	errno = 0;
	// current file status flags
	int flags=fcntl(fd,F_GETFL,0);
	if(errno){
		die("fcntl error");
		return ;
	}
	// add the O_NONBLOCK flag for non-blocking mode
	flags |= O_NONBLOCK; // using bitwise OR to preserve existing flags and add new ones
	
	errno=0;
	// update the flags back to file descriptor
	(void)fcntl(fd,F_SETFL,flags);
	if(errno){
		die("fcntl error");
	}
}

const size_t k_max_msg = 32 << 20; // larger than kernerl buffer (usually 4 to 8 mb's)- 33,554,432 bytes

// Represents per-connection state in an event-driven server.
// This structure allows the application to manage multiple connections asynchronously,
// storing each connection's read/write intentions, closure status, and buffered I/O data.

struct Conn{
	int fd = -1;
	// applications intention , for the event loop
	bool want_read=false;
	bool want_write=false;
	bool want_close=false;
	// now i'm using vectors for buffer manipulation which easier and cleaner ...
	// buffered input and output_iterator
	vector<uint8_t> incoming ; // data to be parsed by the application
	vector<uint8_t> outgoing ; // responses generated by the application 
};

// Append raw bytes to the end of a byte buffer
static void buf_append(vector<uint8_t> &buf,const uint8_t *data , size_t len){
	buf.insert(buf.end(),data,data+len);
}

//Remove processed bytes from the front of a byte buffer
static void buf_consume(vector<uint8_t> &buf,size_t n){
	buf.erase(buf.begin() , buf.begin()+n);
}

// Call back function

    static Conn *handle_accept(int fd){
	struct sockaddr_in client_addr={};
	socklen_t addrlen = sizeof(client_addr);
	int connfd=accept(fd , (struct sockaddr*)&client_addr, &addrlen);
	if(connfd<0){
		cerr<<"Accept() error"<<endl;
		return NULL ;
	}
	uint32_t ip = client_addr.sin_addr.s_addr;
	// LSB
	fprintf(stderr," New client from %u.%u.%u.%u.%u\n",
	ip & 255 ,(ip>>8)&255,(ip>>16)&255,ip>>24,
	ntohs(client_addr.sin_port));
	
	//set the connection fd to nonblocking mode 
	fd_set_nb(fd);
	
	//struct conn
	Conn *conn = new Conn();
	conn->fd =connfd;
	conn->want_read=true;
	return conn;
}

// Process 1 request if there is enough data
// THis protocol assumes the first 4 bytes of incoming data hold the length of the message body.

static bool try_one_request(Conn *conn){
	// parse the protocol header 
	if(conn->incoming.size()<4){
		return false; // want read 
	}
	
	uint32_t len =0;
	memcpy(&len,conn->incoming.data(),4);
	if(len>k_max_msg){
		msg("too long");
		conn->want_close=true;
		return false ; // want close 
	}
	
	// message body 
	if(4+len>conn->incoming.size()){
		return false ; // want read 
	}
	const uint8_t *request = &conn->incoming[4];
	
	// got one request , do some application logic and printing it upto only first 100 char to avoid terminal overloading
	printf("client says: len : %d data : %.*s\n",len,len<100?len:100,request);
	
	// generate the response(echo)
	buf_append(conn->outgoing, (const uint8_t *)&len,4);
	buf_append(conn->outgoing, request ,len);
	
	// application logic done :) remove the request message 
	
	buf_consume(conn->incoming,4+len);
	/* !! we can't just empty the buffer because , multiple requests are coming in the buffer , by the time of responding we may only respond to only one at a time. 
	so after this process emptying the buffer is not suitable cause it may discard the upcoming message requests*/
	return true ;
}

// application callback when the socket is writable

static void handle_write(Conn *conn){
	assert(conn->outgoing.size() > 0);
	ssize_t rv =write(conn->fd , &conn->outgoing[0] , conn->outgoing.size());
	if(rv<0 && errno== EAGAIN){
	return ; // not ready
	}
	if(rv<0){
		msg_errno("write() error)");
		conn->want_close=true; // error handling
		return;
	}
	
	// remove written data from 'outgoing'
	buf_consume(conn->outgoing,(size_t)rv);
	
	// update the readiness intention
	if(conn->outgoing.size()==0){
		// all data written 
		conn->want_read=true;
		conn->want_write=false;
	} // else : want write
}

// application callback when the socket is readable

static void handle_read(Conn *conn){
	// read some data 
	uint8_t buf[64*1024];// 64 kb's
	ssize_t rv= read(conn->fd,buf,sizeof(buf));
	if(rv <0 && errno == EAGAIN){
		return; // not ready
	}
	if(rv<0){
		msg_errno("read() error");
		conn->want_close=true;
	}
	// handle EOF
	if(rv==0){
		if(conn->incoming.size()==0){
			msg("client closed");
		}
		else{
			msg("unexpected EOF");
		}
		conn->want_close=true ;
		return ;
	}
	
    // got some new data 

    buf_append(conn->incoming,buf,(size_t)rv);

    // parse req and generate responses

    while(try_one_request(conn)){} // calling this in a loop - "pipelining"

    // update readiness intention 
	if(conn->outgoing.size()>0){
		// buffer is not empty so stop reading , it was ready to write !!!
		conn->want_read =false;
		conn->want_write=true;
		/* The socket is now ready to write in a request-response protocol,
		try to write it without waiting for the next iteration.*/
	return handle_write(conn);
	} // else want read 
}

int main() {
	// listening socket
    cerr << "Starting server..." << endl;

    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        die("socket()");
    }
    cerr << "Socket created." << endl;

    int val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
	
    //bind
    struct sockaddr_in addr = {};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(5467);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    int rv = bind(fd, (const struct sockaddr *)&addr, sizeof(addr));
    if (rv != 0) {
        die("bind()");
    }
    cerr << "Bind successful." << endl;
    //set the listen fd to nonblocking mode
	fd_set_nb(fd);
	printf("fd was set to non blocking mode\n");
	
	//listen
    rv = listen(fd, SOMAXCONN);
    if (rv != 0) {
        die("listen()");
    }
    cerr << "Listening on port 5467..." << endl;

   // a map of all clients connectios , keyed by fd 
   vector<Conn *> fd2conn;
   // event loop 
   vector<struct pollfd> poll_args;
   while(true){
	   // prepare the arguments of the poll()
	   poll_args.clear(); // clear previous poll arguments 
	   // put listening socket in first position
	   struct pollfd pfd = {fd,POLLIN,0};
	   poll_args.push_back(pfd);
	   
	   // the rest are connection sockets 
	   for(Conn *conn : fd2conn){
		   if(!conn){
			   continue;
		   }
		   // always adds conncetion socket to poll for error
           struct pollfd pfd = {conn->fd,POLLERR,0};
		   if(conn->want_read){
			   pfd.events |= POLLIN;
		   } // Intrested in reading 
		   if(conn->want_write){
			   pfd.events |= POLLOUT ;
		   } // Intrested in writing 
	   
	   poll_args.push_back(pfd);
   }
   // wait for readiness 
   int rv = poll(poll_args.data() , (nfds_t)poll_args.size(),-1);
   if(rv<0 && errno == EINTR){
	   continue;
   }
   if(rv<0){
	   die("poll");
   }
   
   // handle the listening socket
   if(poll_args[0].revents){
	   if(Conn *conn = handle_accept(fd)){
		   if(fd2conn.size() <= (size_t)conn->fd){
			   fd2conn.resize(conn->fd+1);
		   }
		   assert(!fd2conn[conn->fd]); // verify it was not occupied
		   fd2conn[conn->fd]=conn;
	   }
   }
   
   // handle events on existing conncetions 
   for(size_t i=1 ; i<poll_args.size(); i++){
	   // skip the first 
	   uint32_t ready = poll_args[i].revents;
	   if(ready==0){
	   continue;
	   }
   Conn *conn =fd2conn[poll_args[i].fd];
   
   //read data if ready 
   
   if(ready & POLLIN){
	   assert(conn->want_read);
	   handle_read(conn);
   }
   
   // write data if ready 
   
   if(ready & POLLOUT){
	   assert(conn->want_write);
	   handle_write(conn);
   }
   
   // close the socket from socket error or application logic 
   if((ready & POLLERR )||(conn->want_close)){
	   (void)close(conn->fd);
	   fd2conn[conn->fd]=NULL;
	   delete conn ;
      }
    }
  }
    return 0;
}

